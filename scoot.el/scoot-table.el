;;; scoot-table.el --- summary -*- lexical-binding: t -*-
;; -*- read-symbol-shorthands: (("plist-get-in" . "scoot--plist-get-in")) -*-

;; Copyright (C) 2025 Sven Johansson

;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; This file contains the table widget used for result sets and table
;; visualizations of database objects, ie tables.
;;
;; It is not currently a widget in the same sense as inputs or query
;; blocks and does not conform to the interface expressed by
;; scoot-widget.el.
;;
;; Tables are created/inserted into a buffer by the function
;; `scoot-table--insert-table!` and uses a table model generated by
;; `scoot-table--build-visual-model`.
;;
;; The table supports installing temporary widgets for in-place editing
;; of cell values, as well as resizing to fit cell contents.

;;; Code:

(require 'cl-lib)
(require 'scoot-common)
(require 'scoot-input)
(require 'scoot-type)



;; Customization Options

(defcustom scoot-primary-key-icon "ðŸ”‘"
  "Icon used to indicate that a column has a primary key constraint."
  :type 'string
  :group 'scoot)

(defcustom scoot-foreign-key-icon "ðŸ—ï¸"
  "Icon used to indicate that a column has a foreign key constraint."
  :type 'string
  :group 'scoot)



;; Variables

(defvar-local scoot-table--cell-overlay nil
  "A reference to the currently active cell overlay.")



;; Custom faces

(defface scoot-table-header-face
  '((t :inherit bold))
  "Face used for table headers."
  :group 'scoot)

(defface scoot-table-border-face
  '((t :inherit shadow))
  "Face used for resultset table borders."
  :group 'scoot)

(defface scoot-cell-null-face
  '((t :inherit font-lock-comment-face))
  "Face used for null values in result set cells."
  :group 'scoot)

(defface scoot-cell-generic-face
  '((t :inherit default))
  "Face used for default-formatted value type cells."
  :group 'scoot)

(defface scoot-cell-string-face
  '((t :inherit font-lock-string-face))
  "Face used for string values in result set cells."
  :group 'scoot)

(defface scoot-cell-number-face
  '((t :inherit font-lock-number-face))
  "Face used for numeric values in result set cells."
  :group 'scoot)

(defface scoot-cell-boolean-true-face
  '((t :inherit font-lock-keyword-face))
  "Face used for string values in result set cells."
  :group 'scoot)

(defface scoot-cell-boolean-false-face
  '((t :inherit font-lock-operator-face))
  "Face used for string values in result set cells."
  :group 'scoot)

(defface scoot-cell-temporal-face
  '((t :inherit font-lock-constant-face))
  "Face used for temportal values (dates, datetime, timestamps, dateoffsets, etc)
values in result set cells."
  :group 'scoot)

(defface scoot-table-active-cell-face
  '((t :inherit region))
  "Face used to highlight the currently active table cell."
  :group 'scoot)

(defface scoot-table-dirty-cell-marker-face
  '((t :inherit flycheck-error-list-error))
  "Face used to indicate a dirty value in a table cell."
  :group 'scoot)

(defface scoot-table-row-marker-delete-face
  '((t (:background "#482121")))
  "Face used in row marker overlay  to signal a row containing modified values."
  :group 'scoot)

(defface scoot-table-row-marker-update-face
  '((t (:background "#212148")))
  "Face used in row marker overlay  to signal a row containing modified values."
  :group 'scoot)



;; Formatting

(defvar scoot-formatter-header
  (list :align 'left
        :format-value (lambda (name metadata)
                        (format "%s%s"
                                (cond ((eq t (alist-get 'primary_key metadata))
                                       scoot-primary-key-icon)

                                      ((cl-some
                                        (lambda (con)
                                          (equal (alist-get 'type con) "fk"))
                                        (alist-get 'constraints metadata))
                                       scoot-foreign-key-icon)

                                      (t ""))
                                name))
        :output-cell (lambda (_ formatted-value)
                       (insert (propertize formatted-value
                                           'face 'scoot-table-header-face)))))



;; Table Model

(defun scoot--column-width (val)
  "Calculates the width of string value of VAL.

Uses `string-pixel-width' of the string representation of VAL to account
for special characters and icons/emojis that do not align with the the
default width of the, presumably, otherwise fixed-width font."
  (if (display-graphic-p)
      (let* ((pixel-width (string-pixel-width (format "%s" val)))
             (char-width (default-font-width)))
        (/ pixel-width char-width))
    (string-width (format "%s" val))))

(defun scoot-table--build-visual-model (result-data)
  "Build the table data model from RESULT-DATA."
  (let* ((columns-metadata (if-let* ((col-meta
                                      (alist-get 'columns
                                                 (alist-get 'metadata
                                                            result-data)))
                                     (_ (> (length col-meta) 0)))
                               col-meta
                             (mapcar (lambda (col-name)
                                       (list (cons 'name col-name)))
                                     (alist-get 'columns result-data))))
         (formatters (mapcar
                      #'scoot--resolve-formatter-from-column-metadata
                      columns-metadata))
         (headers (mapcar
                   (lambda (column-metadata)
                     (let ((name (alist-get 'name column-metadata)))
                       (list :name (alist-get 'name column-metadata)
                             :header-label
                             (scoot--format-value scoot-formatter-header
                                                  name
                                                  column-metadata)
                             :metadata column-metadata)))
                   columns-metadata))
         (tables (cl-remove-duplicates (mapcar
                                        (lambda (h)
                                          (alist-get 'table (plist-get h :metadata)))
                                        headers)
                                       :test 'string-equal))
         (raw-table-data (alist-get 'rows result-data))
         (records (cl-mapcar
                   (lambda (row)
                     (cl-mapcar (lambda (cell-value fmt col)
                                  (let ((formatter (if (null cell-value)
                                                       scoot-formatter-null
                                                     fmt)))
                                    (list :value (cond
                                                  ;; Temporary ugly, no good, verybad hack to standardize date output between backends
                                                  ((and cell-value
                                                        (member (alist-get 'native_type col) '("datetimeoffset" "DATETIMEOFFSET" "TIMESTAMP" "TIMESTAMP WITH TIME ZONE")))
                                                   (scoot--format-temporal cell-value))
                                                  (t cell-value))
                                          :formatted-value
                                          (funcall
                                           (plist-get formatter :format-value)
                                           cell-value))))
                                row
                                formatters
                                columns-metadata))
                   raw-table-data))
         (widths (cl-mapcar
                  (lambda (width header)
                    (max width (scoot--column-width (plist-get header
                                                               :header-label))))
                  (if records
                      (apply #'cl-mapcar
                             (lambda (&rest col)
                               (apply #'max
                                      (mapcar (lambda (cell)
                                                (scoot--column-width
                                                 (plist-get cell
                                                            :formatted-value)))
                                              col)))
                             records)
                    (make-list (length headers) 0))
                  headers)))
    (list :headers headers
          :tables tables
          :widths widths
          :formatters formatters
          :records records)))

(defun scoot-table--record-identity (record)
  "Extract the record identity from RECORD."
  (list :id (plist-get (nth 0 record) :value)))

(defun scoot-table--cell-modified-p (record-cell)
  "Determines if RECORD-CELL has been modified.

It is considered to be modified if it contains an
:original-value property."
  (plist-member record-cell :original-value))

(defun scoot-table--record-modified-p (record)
  "Determines if TEST RECORD has been modified.

It is considered to be modified if at least one of its cells
has stored an :original-value property."
  (cl-some #'scoot-table--cell-modified-p record))



;; Table Rendering

(defun scoot-table--insert-table-header (table)
  "Insert result set header for widget TABLE."
  (scoot-table--insert-divider-row table)

  (cl-mapc (lambda (header width)
             (insert (propertize "| "
                                 'thing 'table-border
                                 'face 'scoot-table-border-face))
             (let* ((header-begin (1- (point)))
                    (align (plist-get scoot-formatter-header :align))
                    (name (plist-get header :name))
                    (header-label (plist-get header :header-label))
                    (padding (- width (scoot--column-width header-label))))
               (when (eq align 'right)
                 (insert (make-string padding ?\s)))
               (funcall
                (plist-get scoot-formatter-header :output-cell)
                name
                header-label)
               (when (eq align 'left)
                 (insert (make-string padding ?\s)))
               (insert " ")
               (add-text-properties header-begin (point) (list 'thing 'table-header
                                                               'header name
                                                               'column-meta (plist-get header :metadata)
                                                               'column (alist-get 'column (plist-get header :metadata))
                                                               'table (alist-get 'table (plist-get header :metadata))))))
           (plist-get-in table :model :headers)
           (plist-get-in table :model :widths))
  (insert (propertize "|"
                      'thing 'table-border
                      'face 'scoot-table-border-face))
  (insert "\n")

  (scoot-table--insert-divider-row table))

(defun scoot-table--insert-table-cell (record cell header width fmt column-index editablep)
  "Insert the table cell CELL.

Requires:
RECORD - The record that the cell belongs to.
HEADER - The table model header description for the column.
WIDTH - The table model width for the column.
FMT - The formatter for this cell/column.
COLUMN-INDEX - The column index.
EDITABLEP - Allow the cell to be edited, t/nil."
  (let* ((cell-start (point))
         (value (plist-get cell :value))
         (dirty-p (scoot-table--cell-modified-p cell))
         (formatted-value (plist-get cell :formatted-value))
         (formatter (if (null value)
                        scoot-formatter-null
                      fmt))
         (align (plist-get formatter :align))
         (padding (- width (string-width formatted-value)))
         (header-meta (plist-get header :metadata))
         (cell-props (list 'thing 'table-cell
                           'editablep editablep
                           'column-meta header-meta
                           'formatter formatter
                           'value value
                           'record-cell cell
                           'record record
                           'cell-index column-index)))
    (if dirty-p
        (insert (propertize ">"
                            'thing 'table-cell
                            'face 'scoot-table-dirty-cell-marker-face))
      (insert (propertize " "
                          'thing 'table-cell)))
    (when (eq align 'right)
      (insert (make-string padding ?\s)))
    (let ((value-start (point)))
      (funcall
       (plist-get formatter :output-cell)
       value
       formatted-value)
      (when dirty-p
        (add-text-properties value-start (point) `(face (:slant italic :inherit ,(get-text-property value-start 'face))))))
    (when (eq align 'left)
      (insert (make-string padding ?\s)))
    (insert " ")
    (add-text-properties cell-start (point) cell-props)))

(defun scoot-table--insert-table-row (table record editablep)
  "Insert a table row containing RECORD.

TABLE - The table widget being rendered
EDITABLEP - Signal if editing of the record is allowed."
  (let ((record-identity (scoot-table--record-identity record))
        (border (propertize
                 "|"
                 'thing 'table-border
                 'table-row (list :record record)
                 'face 'scoot-table-border-face)))
    (cl-loop for header in (plist-get-in table :model :headers)
             for cell in record
             for width in (plist-get-in table :model :widths)
             for fmt in (plist-get-in table :model :formatters)
             for index from 0
             do
             (insert border)
             (scoot-table--insert-table-cell record
                                             cell
                                             header
                                             width
                                             fmt
                                             index
                                             editablep))
    (insert border)
    (when-let* ((row-mark (scoot-table--get-row-mark table record-identity))
                (type (and (overlayp row-mark) (overlay-get row-mark 'type))))
      (scoot-table--mark-row! table record-identity type))
    (insert "\n")))


(defun scoot-table--insert-divider-row (table)
  "Insert a horizontal table divider for TABLE."
  (insert (propertize
           (concat "+-"
                   (mapconcat (lambda (w) (make-string w ?-))
                              (scoot--plist-get-in table :model :widths)
                              "-+-")
                   "-+\n")
           'thing 'table-border
           'face 'scoot-table-border-face)))

(defun scoot-table--insert-table! (result-data &optional editablep)
  "Insert the RESULT-DATA table into the buffer.

EDITABLEP - Signal if editing of the table data is to be allowed."
  (scoot-widget--create
      :type 'table
      :name 'table
      :opts ((model (scoot-table--build-visual-model result-data)))
      :init
      (progn
        (plist-put widget :model model)
        (plist-put widget :row-marks (make-hash-table :test #'equal))
        (plist-put widget :on-destroy (lambda (table)
                                        (maphash (lambda (id _)
                                                   (scoot-table--remove-row-mark! table id))
                                              (plist-get table :row-marks))))
        (scoot-table--insert-table-header widget)
        (dolist (record (plist-get model :records))
          (scoot-table--insert-table-row widget record editablep))
        (scoot-table--insert-divider-row widget))))



;; Table inspection

(defun scoot-table--table-at-point-p ()
  "Return non-nil if the cursor is inside the table bounds."
  (scoot--thing-at-p (point) '(table-cell
                               table-header
                               table-border)))

(defun scoot-table--table-start ()
  "Return the first point of the table in the buffer.

Returns the position in the format of (<point> . <line-number>)"
  (save-excursion
    (while (and (not (bobp)) (scoot-table--table-at-point-p))
      (forward-line -1))
    (goto-char (line-beginning-position))
    (when (not (scoot-table--table-at-point-p))
      (forward-line 1))
    (cons (point) (line-number-at-pos))))

(defun scoot-table--cell-at-point ()
  "Return the result set table cell at point."
  (let* ((props (scoot--props-at-point)))
    (when (eq (alist-get 'thing props) 'table-cell)
      (list :type (alist-get 'thing props)
            :column (alist-get 'column-meta props)
            :value (alist-get 'value props)
            :record-cell (alist-get 'record-cell props)
            :record (alist-get 'record props)
            :formatter (alist-get 'formatter props)
            :cell-index (alist-get 'cell-index props)
            :editablep (alist-get 'editablep props)))))

(defun scoot-table--row-at-point ()
  "Return the result set table row at point."
  (when (scoot-table--table-at-point-p)
    (alist-get 'table-row (scoot--props-at-point (line-beginning-position)))))

(defun scoot-table--cell-begin (&optional point)
  "Find the location of the first char of the cell at POINT.

Returns (<point> . <line-number>)."
  (let ((p (or point (point))))
    (when (scoot--thing-at-p p '(table-cell table-header))
      (while (scoot--thing-at-p (1- p) '(table-cell table-header))
        (setq p (1- p)))
      (setq p (1+ p))
      (cons p (line-number-at-pos p)))))

(defun scoot-table--cell-end (&optional point)
  "Find the location of the first char of the cell at POINT.

Returns (<point> . <line-number>)."
  (let ((p (or point (point))))
    (when (scoot--thing-at-p p '(table-cell table-header))
      (setq p (next-single-property-change p 'thing))
      (when p
        (setq p (- p (if (not (scoot--thing-at-p p '(table-cell table-header))) 2 1)))
        (cons p (line-number-at-pos p))))))


(defun scoot-table--next-cell (&optional point)
  "Find the location of the the next table-cell of the buffer.

If POINT is not provided, the search will start from the beginning
of the buffer.

Returns a cons cell of (<point> . <line-number>)"
  (save-excursion
    (when point (goto-char point))
    (when-let (point (scoot--next-property-with-value-in
                      'thing
                      '(table-cell table-header)))
      (goto-char point)
      (cons point (line-number-at-pos)))))

(defun scoot-table--previous-cell (&optional point)
  "Find the location of the the previous table-cell of the buffer.

If POINT is not provided, the search will start from the end of the
buffer."
  (save-excursion
    (when point (goto-char point))
    (when-let (point (scoot--previous-property-with-value-in
                      'thing
                      '(table-cell table-header)))
      (goto-char point)
      (cons point (line-number-at-pos)))))



;; Table Navigation

(defun scoot-table--move-to-cell-value ()
  "Move the cursor to the align anchor of the cell value."
  (if (or (equal (plist-get (alist-get 'formatter (scoot--props-at-point)) :align) 'left)
          (not (car (assoc 'value (scoot--props-at-point)))))
      (goto-char (or (car (scoot-table--cell-begin (point))) (point)))
    (goto-char (or (car (scoot-table--cell-end (point))) (point)))))

(defun scoot-table--move-to-first-column ()
  "Move the cursor to the first column of the current row."
  (interactive)
  (beginning-of-line)
  (scoot-table--cell-right!))

(defun scoot-table--move-to-last-column ()
  "Move the cursor to the first column of the current row."
  (interactive)
  (end-of-line)
  (when-let ((pt (scoot--previous-property-with-value-in 'thing '(table-cell table-header))))
    (goto-char pt)
    (scoot-table--move-to-cell-value)))

(defun scoot-table--move-to-first-row! ()
  "Move the cursor to the first row."
  (interactive)
  (let ((ccol (current-column))
        (tbl-start (scoot-table--table-start)))
    (goto-char (car tbl-start))
    (while (not (scoot-table--row-at-point))
      (forward-line 1))
    (forward-char ccol)
    (when (scoot-table--cell-at-point)
      (scoot-table--move-to-cell-value))))

(defun scoot-table--move-to-last-row! ()
  "Move the cursor to the first row."
  (interactive)
  (scoot-table--move-to-first-row!)
  (let ((ccol (current-column)))
    (while (scoot-table--row-at-point)
      (forward-line 1))
    (forward-line -1)
    (when (scoot-table--cell-at-point)
      (scoot-table--move-to-cell-value))
    (forward-char ccol)
    (when (scoot-table--cell-at-point)
      (scoot-table--move-to-cell-value))))

(defun scoot-table--cell-right! ()
  "Move right to the next cell."
  (interactive)
  (when-let (cell (scoot-table--next-cell (point)))
    (goto-char (car cell))
    (scoot-table--move-to-cell-value)))

(defun scoot-table--cell-left! ()
  "Move right to the previous cell."
  (interactive)
  (when-let (cell (scoot-table--previous-cell (point)))
    (goto-char (car cell))
    (scoot-table--move-to-cell-value)))

(defun scoot-table--cell-up! ()
  "Move up to the corresponding cell in the previous row."
  (interactive)
  (let ((line-move-visual nil))
    (call-interactively #'previous-line)
    (when (scoot--thing-at-p (point) '(table-cell table-header))
      (scoot-table--move-to-cell-value))))

(defun scoot-table--cell-down! ()
  "Move up to the corresponding cell in the previous row."
  (interactive)
  (let ((line-move-visual nil)
        (col (current-column)))
    (forward-line 1)
    (move-to-column col)
    (when (scoot--thing-at-p (point) '(table-cell table-header))
      (scoot-table--move-to-cell-value))))



;; Cell Editing

(defun scoot-table--resize-column! (table column-index new-width)
  "Resize column with index COLUMN-INDEX to NEW-WIDTH in TABLE."
  (condition-case err
      (save-excursion
        (scoot-table--move-to-first-row!)
        (scoot-table--move-to-first-column)
        (dotimes (_ column-index)
          (scoot-table--cell-right!))
        (goto-char (1+ (car (scoot-table--cell-end))))
        (let* ((inhibit-read-only t)
               (rcol (current-column))
               (current-width (- (car (scoot-table--cell-end))
                                 (car (scoot-table--cell-begin))))
               (diff (- new-width current-width))
               (input-lines (mapcar (lambda (w)
                                      (line-number-at-pos (or (plist-get (cdr w) :widget-start) 1)))
                                    scoot--active-widgets))
               (model-col-width (nth column-index (plist-get-in table :model :widths))))
          (setf (nth column-index (plist-get-in table :model :widths)) (+ model-col-width diff))
          (forward-line -3)
          (if (> diff 0)
              (dotimes (_ (+ 4 (length (plist-get-in table :model :records))))
                (unless (member (line-number-at-pos (point)) input-lines)
                  (move-to-column rcol)
                  (insert (string-join (make-list
                                        diff
                                        (buffer-substring (point) (1+ (point))))
                                       "")))
                (forward-line 1))
            (dotimes (_ (+ 4 (length (plist-get-in table :model :records))))
              (unless (member (line-number-at-pos (point)) input-lines)
                (move-to-column rcol)
                (delete-region (- (point) diff) (point)))
              (forward-line 1)))))
    (error
     (message "Error while adjusting column size: %s - %s" (car err) (cdr err)))))

(defun scoot-table--edit-cell-resize-hook (table column-index new-width)
  "Hook that runs when cell editing forces the column width to change.

TABLE is the table being resized.
COLUMN-INDEX is the visual index of the column that has changed.
NEW-WIDTH is the new column width in characters."
  (scoot-table--resize-column! table column-index new-width))

(defun scoot-table--remove-cell-editor! (table widget cell)
  "Uninstalls the editable cell and restores a regular table cell.

TABLE is the table that the input is attached to.
WIDGET is the input widget being uninstalled.
CELL is the cell summary of the cell under edit."
  (let* ((widget-start (marker-position (plist-get widget :widget-start)))
         (widget-end (marker-position (plist-get widget :widget-end)))
         (formatter (plist-get widget :formatter))
         (cell-index (plist-get cell :cell-index))
         (record (plist-get cell :record))
         (record-cell (plist-get cell :record-cell))
         (identity (scoot-table--record-identity record))
         (inhibit-read-only t))
    (delete-region (1- widget-start) (+ 1 widget-end))
    (goto-char (1- widget-start))
    (scoot-table--insert-table-cell record
                                    record-cell
                                    (nth cell-index (plist-get-in table :model :headers))
                                    (nth cell-index (plist-get-in table :model :widths))
                                    formatter
                                    cell-index
                                    t)
    (goto-char (+ widget-start (length (plist-get record-cell :formatted-value))))
    (scoot-table-mode 1)
    (if (scoot-table--record-modified-p record)
        (scoot-table--mark-row! table identity :update)
      (scoot-table--remove-row-mark! table identity :update))))

(defun scoot-table--edit-cell ()
  "Enter edit mode at the cell at point."
  (interactive)
  (if-let* ((table (scoot-widget--at-point :type 'table))
            (cell (scoot-table--cell-at-point)))
      (if (plist-get cell :editablep)
          (let ((input (scoot-input--install-input!
                        :begin (car (scoot-table--cell-begin))
                        :end (1+ (car (scoot-table--cell-end)))
                        :column (plist-get cell :column)
                        :type (alist-get 'typespec (plist-get cell :column))
                        :formatter (get-text-property (point) 'formatter)
                        :record-cell (plist-get cell :record-cell)
                        :record (plist-get cell :record)
                        :resize-hook (lambda (new-width)
                                       (scoot-table--edit-cell-resize-hook
                                        table (plist-get cell :cell-index) new-width))
                        :remove-hook (lambda (widget)
                                       (scoot-table--remove-cell-editor! table widget cell)))))
            (scoot-table-mode -1)
            input)
        (message "Table cell is not editable"))
    (message "No table cell at point")))



;; Copy values


(defun scoot-table--kill-ring-save-column-values ()
  "Save a comma-separated list of the values of column at point to kill ring."
  (interactive)
  (let* ((table (scoot-widget--at-point :type 'table))
         (cell (scoot-table--cell-at-point))
         (formatter (plist-get cell :formatter))
         (cell-index (plist-get cell :cell-index)))
    (when (integerp cell-index)
      (let* ((values (mapcar
                      (lambda (record)
                        (scoot--format-literal
                         formatter
                         (plist-get (nth cell-index record)
                                    :value)))
                      (plist-get-in table :model :records)))
             (result (string-join values ", ")))
        (kill-new result)
        (message result)))))

(defun scoot-table--kill-ring-save-row-values ()
  "Save a comma-separated list of the values of column at point to kill ring."
  (interactive)
  (let* ((table (scoot-widget--at-point :type 'table))
         (row (scoot-table--row-at-point))
         (record (plist-get row :record))
         (result (string-join
               (cl-loop for cell in record
                        for formatter in (plist-get-in table :model :formatters)
                        collect (scoot--format-literal formatter (plist-get cell :value)))
               ", ")))
    (kill-new result)
    (message result)))

(defun scoot-table--kill-ring-save-cell-value ()
  "Save a comma-separated list of the values of column at point to kill ring."
  (interactive)
  (let* ((cell (scoot-table--cell-at-point))
         (formatter (plist-get cell :formatter))
         (result (scoot--format-literal formatter (plist-get cell :value))))
    (kill-new result)
    (message result)))



;; Row/Table marks

(defun scoot-table--get-row-mark (table identity &optional type)
  "Get the row mark for IDENTITY in TABLE if it exists.

If TYPE is provided the mark will only be returned if the existing
mark for row with IDENTITY matches TYPE."
  (when-let ((mark (gethash identity (plist-get table :row-marks))))
    (when (or (null type)
              (equal (overlay-get mark 'type)
                     type))
      mark)))

(defun scoot-table--remove-row-mark! (table identity &optional type)
  "Remove row mark for IDENTITY in TABLE if it exists.

If TYPE is provided the mark will only be removed if the existing
mark for row with IDENTITY matches TYPE.

Returns t if a row mark was removed."
  (when-let* ((mark (scoot-table--get-row-mark table identity type)))
    (delete-overlay mark)
    (remhash identity (plist-get table :row-marks))
    t))

(defun scoot-table--mark-row! (table identity type)
  "Mark overlay of type TYPE for row with identity IDENTITY in TABLE."
  (scoot-table--remove-row-mark! table identity)
  (let ((overlay (make-overlay (line-beginning-position) (line-end-position))))
    (overlay-put overlay 'type type)
    (pcase type
      (:delete (overlay-put overlay 'face 'scoot-table-row-marker-delete-face))
      (:update (overlay-put overlay 'face 'scoot-table-row-marker-update-face)))
    (puthash identity overlay (plist-get table :row-marks))))


(defun scoot-table--toggle-mark-delete ()
  "Toggle mark for deletion at row at point."
  (interactive)
  (when-let ((table (scoot-widget--at-point :type 'table))
             (row (scoot-table--row-at-point)))
    (if-let ((identity (scoot-table--record-identity (plist-get row :record))))
        (progn (if (scoot-table--remove-row-mark! table identity :delete)
                   (when (scoot-table--record-modified-p
                          (plist-get (scoot-table--row-at-point) :record))
                     (scoot-table--mark-row! table identity :update))
                 (scoot-table--mark-row! table identity :delete))
               (scoot-table--cell-down!))
      (message "Cannot uniquely identify the row at point."))))



;; Scoot Table Mode - scoot-table--mode

(defvar scoot-table-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-a") 'scoot-table--move-to-first-column)
    (define-key map (kbd "C-e") 'scoot-table--move-to-last-column)
    (define-key map (kbd "M-a") 'scoot-table--move-to-first-row!)
    (define-key map (kbd "M-e") 'scoot-table--move-to-last-row!)
    (define-key map (kbd "C-n") 'scoot-table--cell-down!)
    (define-key map (kbd "C-p") 'scoot-table--cell-up!)
    (define-key map (kbd "C-f") 'scoot-table--cell-right!)
    (define-key map (kbd "TAB") 'scoot-table--cell-right!)
    (define-key map (kbd "C-b") 'scoot-table--cell-left!)
    (define-key map (kbd "<backtab>") 'scoot-table--cell-left!)
    (define-key map (kbd "RET") 'scoot-table--edit-cell)
    (define-key map (kbd "d") 'scoot-table--toggle-mark-delete)
    (define-key map (kbd "<deletechar>") 'scoot-table--toggle-mark-delete)
    (define-key map (kbd "C-c w c") 'scoot-table--kill-ring-save-column-values)
    (define-key map (kbd "C-c w r") 'scoot-table--kill-ring-save-row-values)
    (define-key map (kbd "C-c w .") 'scoot-table--kill-ring-save-cell-value)
    map))

(define-minor-mode scoot-table-mode
  "Minor mode for navigating and interacting with tables."
  :lighter " Table"
  :keymap scoot-table-mode-map

  (if scoot-table-mode
      (add-hook 'post-command-hook 'scoot-table--update-overlay nil t)
    (remove-hook 'post-command-hook 'scoot-table--update-overlay t))
  (scoot-table--update-overlay))

(defun scoot-table--update-overlay ()
  "Update the overlay over the current table-cell."
  (if (and scoot-table-mode (scoot--thing-at-p (point) 'table-cell))
      (progn
        (unless (and scoot-table--cell-overlay
                     (overlay-start scoot-table--cell-overlay)
                     (>= (point) (1- (overlay-start scoot-table--cell-overlay)))
                     (<= (point) (1+ (overlay-end scoot-table--cell-overlay))))
          (when scoot-table--cell-overlay
            (delete-overlay scoot-table--cell-overlay))
          (setq scoot-table--cell-overlay (make-overlay (car (scoot-table--cell-begin (point)))
                                                        (1+ (car (scoot-table--cell-end (point))))))
          (overlay-put scoot-table--cell-overlay
                       'face 'scoot-table-active-cell-face)))
    (when scoot-table--cell-overlay
      (delete-overlay scoot-table--cell-overlay))))

(provide 'scoot-table)

;;; scoot-table.el ends here
;; Local Variables:
;; read-symbol-shorthands: (("plist-get-in" . "scoot--plist-get-in"))
;; End:


