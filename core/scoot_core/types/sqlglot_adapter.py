from typing import override

from sqlalchemy import Dialect
from sqlglot import exp

from .adapter import TypeAdapter, Types

"""
Maps scoot_core.types.Types to sqlglot DataType.Type.
"""
SqlGlotTypes: dict[Types, list[exp.DataType.Type]] = {
    Types.STRING: [exp.DataType.Type.VARCHAR]
}


class SqlGlotType(TypeAdapter):
    """
    TypeAdapter implementation for sqlglot DataType and/or ColumnDef
    expressions.

    This adapter may be used with a plain DataType, but without a ColumnDef
    instance certain type information will be unavailable.

    column: exp.ColumnDef | None
    datatype: exp.DataType
    dialect: str | None
    """

    def __init__(self, type: exp.DataType | exp.ColumnDef, dialect: str | None):
        """
        Initialize the SqlGlotType adapter.

        Args:
            type (exp.DataType | exp.ColumnDef): The sqlglot type expression
                to adapt.
            dialect (str | None): The SQL dialect name for rendering.
        """
        self.column = type if isinstance(type, exp.ColumnDef) else None
        if self.column:
            datatype = self.column.args.get("kind")
            if not isinstance(datatype, exp.DataType):
                raise TypeError(f"Invalid type/column: {type}")
            self.datatype = datatype
        elif isinstance(type, exp.DataType):
            self.datatype = type
        self.dialect = dialect

    @override
    def get_collation(self) -> str | None:
        """
        Get the collation of the sqlglot type if applicable.

        Always returns None for types that are not considered by sqlglot
        to be a TEXT_TYPE.

        Only available when the adapter contains a ColumnDef instance.

        Returns:
            str | None: The collation name if applicable, otherwise None.
        """
        if not self.column:
            return None

        if collate := self.column.find(exp.CollateColumnConstraint):
            return str(collate.this)

        return None

    @override
    def get_precision(self) -> int | None:
        raise NotImplementedError

    @override
    def get_scale(self) -> int | None:
        raise NotImplementedError

    @override
    def get_timezone(self) -> str | None:
        if self.datatype.this == exp.DataType.Type.TIMESTAMPTZ:
            # Fixme: Can we get to the _actual_ timezone here?
            return "t"
        return None

    @override
    def is_type(self, type: Types) -> bool:
        """
        Check if the sqlglot type matches the given Types enum.


        Args:
            type (Types): The type to check against.
        Returns:
            bool: True if the type matches, otherwise False.
        """
        return any(self.datatype.is_type(glot_type) for glot_type in SqlGlotTypes[type])

    @override
    def max_length(self) -> int | None:
        """
        Get the maximum length of the sqlglot type if applicable.

        Returns:
            int | None: The maximum length if applicable, otherwise None.
        """
        if self.is_type(Types.STRING):
            typearg = next(expr for expr in self.datatype.args.get("expressions", []))
            if typearg:
                return int(str(typearg))
        return None

    @override
    def native_expression(self, dialect: Dialect) -> str:
        """
        Get the native type expression for the given SQL dialect.

        Native in this case refers to the syntax of the SQL dialect as
        generated by sqlglot.

        Args:
            dialect (Dialect): The SQLAlchemy dialect to use for rendering.

        Returns:
            str: The native type expression.
        """
        if self.column and (
            collate_constr := self.column.find(exp.CollateColumnConstraint)
        ):
            return f"{self.datatype.sql(dialect=self.dialect)} {collate_constr}"
        return self.datatype.sql(dialect=self.dialect)

    @classmethod
    def from_datatype(
        cls, type: exp.DataType | exp.ColumnDef, dialect: str | None
    ) -> "SqlGlotType":
        """
        Create a SqlGlotType instance from a sqlglot DataType or ColumnDef.

        Args:
            type (exp.DataType | exp.ColumnDef): The sqlglot type expression
                to adapt.
            dialect (str | None): The SQL dialect name for rendering.
        """
        return cls(type, dialect)

    def __str__(self):
        """
        Get the string representation of the sqlglot type.
        """
        return self.datatype.sql(dialect=self.dialect)
